{"ast":null,"code":"import { registerPlugin } from '@capacitor/core';\nconst EVENT_FETCH = \"fetch\";\nconst TAG = \"BackgroundFetch\";\nconst STATUS_RESTRICTED = 0;\nconst STATUS_DENIED = 1;\nconst STATUS_AVAILABLE = 2;\nconst NETWORK_TYPE_NONE = 0;\nconst NETWORK_TYPE_ANY = 1;\nconst NETWORK_TYPE_UNMETERED = 2;\nconst NETWORK_TYPE_NOT_ROAMING = 3;\nconst NETWORK_TYPE_CELLULAR = 4;\nconst NativeModule = registerPlugin('BackgroundFetch');\nlet subscriber = null;\n/**\n* BackgroundFetch is a module to receive periodic callbacks (min every 15 min) while your app is running in the background or terminated.\n*\n* ```javascript\n* import {BackgroundFetch} from '@transistorsoft/capacitor-background-fetch';\n*\n* class HomePage {\n*\n*   // Initialize in ngAfterContentInit\n*   // [WARNING] DO NOT use ionViewWillEnter, as that method won't run when app is launched in background.\n*   ngAfterContentInit() {\n*     this.initBackgroundFetch();\n*   }\n*\n*   async initBackgroundFetch() {\n*     const status = await BackgroundFetch.configure({\n*       minimumFetchInterval: 15\n*     }, async (taskId) => {  // <---------------- Event handler.\n*       console.log('[BackgroundFetch] EVENT:', taskId);\n*       // Perform your work in an awaited Promise\n*       const result = await this.performYourWorkHere();\n*       console.log('[BackgroundFetch] work complete:', result);\n*       // [REQUIRED] Signal to the OS that your work is complete.\n*       BackgroundFetch.finish(taskId);\n*     }, async (taskId) => {  // <---------------- Event timeout handler\n*       // The OS has signalled that your remaining background-time has expired.\n*       // You must immediately complete your work and signal #finish.\n*       console.log('[BackgroundFetch] TIMEOUT:', taskId);\n*       // [REQUIRED] Signal to the OS that your work is complete.\n*       BackgroundFetch.finish(taskId);\n*     });\n*\n*     // Checking BackgroundFetch status:\n*     if (status !== BackgroundFetch.STATUS_AVAILABLE) {\n*       // Uh-oh:  we have a problem:\n*       if (status === BackgroundFetch.STATUS_DENIED) {\n*         alert('The user explicitly disabled background behavior for this app or for the whole system.');\n*       } else if (status === BackgroundFetch.STATUS_RESTRICTED) {\n*         alert('Background updates are unavailable and the user cannot enable them again.')\n*       }\n*     }\n*   }\n*\n*   // Simulate a long-running task (eg:  an HTTP request)\n*   async performYourWorkHere() {\n*     return new Promise((resolve, reject) => {\n*       setTimeout(() => {\n*         resolve(true);\n*       }, 5000);\n*     });\n*   }\n* }\n* ```\n* ## iOS\n* - There is **no way** to increase the rate which a fetch-event occurs and this plugin sets the rate to the most frequent possible &mdash; you will **never** receive an event faster than **15 minutes**.  The operating-system will automatically throttle the rate the background-fetch events occur based upon usage patterns.  Eg: if user hasn't turned on their phone for a long period of time, fetch events will occur less frequently.\n* - [__`scheduleTask`__](#executing-custom-tasks) seems only to fire when the device is plugged into power.\n* - ⚠️ When your app is **terminated**, iOS *no longer fires events* &mdash; There is *no such thing* as **`stopOnTerminate: false`** for iOS.\n* - iOS can take *days* before Apple's machine-learning algorithm settles in and begins regularly firing events.  Do not sit staring at your logs waiting for an event to fire.  If your [*simulated events*](#debugging) work, that's all you need to know that everything is correctly configured.\n* - If the user doesn't open your *iOS* app for long periods of time, *iOS* will **stop firing events**.\n*\n* ## Android\n* - The Android plugin is capable of operating after app terminate (see API docs [[BackgroundFetchConfig.stopOnTerminate]], [[BackgroundFetchConfig.enableHeadless]]) but only by implementing your work with Java code.\n*/\nexport class BackgroundFetch {\n  /**\n  * Background fetch updates are unavailable and the user cannot enable them again. For example, this status can occur when parental controls are in effect for the current user.\n  */\n  static get STATUS_RESTRICTED() {\n    return STATUS_RESTRICTED;\n  }\n  /**\n  * The user explicitly disabled background behavior for this app or for the whole system.\n  */\n  static get STATUS_DENIED() {\n    return STATUS_DENIED;\n  }\n  /**\n  * Background fetch is available and enabled.\n  */\n  static get STATUS_AVAILABLE() {\n    return STATUS_AVAILABLE;\n  }\n  /**\n  * This job doesn't care about network constraints, either any or none.\n  */\n  static get NETWORK_TYPE_NONE() {\n    return NETWORK_TYPE_NONE;\n  }\n  /**\n  * This job requires network connectivity.\n  */\n  static get NETWORK_TYPE_ANY() {\n    return NETWORK_TYPE_ANY;\n  }\n  /**\n  * This job requires network connectivity that is a cellular network.\n  */\n  static get NETWORK_TYPE_CELLULAR() {\n    return NETWORK_TYPE_CELLULAR;\n  }\n  /**\n  * This job requires network connectivity that is unmetered.\n  */\n  static get NETWORK_TYPE_UNMETERED() {\n    return NETWORK_TYPE_UNMETERED;\n  }\n  /**\n  * This job requires network connectivity that is not roaming.\n  */\n  static get NETWORK_TYPE_NOT_ROAMING() {\n    return NETWORK_TYPE_NOT_ROAMING;\n  }\n  /**\n  * Initial configuration of BackgroundFetch, including config-options and Fetch-callback.  The [[start]] method will automatically be executed.\n  *\n  * ```javascript\n  *   async initBackgroundFetch() {\n  *     const status = await BackgroundFetch.configure({\n  *       minimumFetchInterval: 15\n  *     }, async (taskId) => {  // <---------------- Event handler.\n  *       console.log('[BackgroundFetch] EVENT:', taskId);\n  *       // Perform your work in an awaited Promise\n  *       const result = await this.performYourWorkHere();\n  *       console.log('[BackgroundFetch] work complete:', result);\n  *       // [REQUIRED] Signal to the OS that your work is complete.\n  *       BackgroundFetch.finish(taskId);\n  *     }, async (taskId) => {  // <---------------- Event timeout handler\n  *       // The OS has signalled that your remaining background-time has expired.\n  *       // You must immediately complete your work and signal #finish.\n  *       console.log('[BackgroundFetch] TIMEOUT:', taskId);\n  *       // [REQUIRED] Signal to the OS that your work is complete.\n  *       BackgroundFetch.finish(taskId);\n  *     });\n  *\n  *     // Checking BackgroundFetch status:\n  *     if (status !== BackgroundFetch.STATUS_AVAILABLE) {\n  *       // Uh-oh:  we have a problem:\n  *       if (status === BackgroundFetch.STATUS_DENIED) {\n  *         alert('The user explicitly disabled background behavior for this app or for the whole system.');\n  *       } else if (status === BackgroundFetch.STATUS_RESTRICTED) {\n  *         alert('Background updates are unavailable and the user cannot enable them again.')\n  *       }\n  *     }\n  *   }\n  *\n  *   // Simulate a long-running task (eg:  an HTTP request)\n  *   async performYourWorkHere() {\n  *     return new Promise((resolve, reject) => {\n  *       setTimeout(() => {\n  *         resolve(true);\n  *       }, 5000);\n  *     });\n  *   }\n  * }\n  * ```\n  */\n  static configure(config, onEvent, onTimeout) {\n    if (typeof onEvent !== 'function') {\n      throw \"BackgroundFetch requires an event callback at 2nd argument\";\n    }\n    if (typeof onTimeout !== 'function') {\n      console.warn(\"[BackgroundFetch] configure:  You did not provide a 3rd argument onTimeout callback.  This callback is a signal from the OS that your allowed background time is about to expire.  Use this callback to finish what you're doing and immediately call BackgroundFetch.finish(taskId)\");\n      onTimeout = taskId => {\n        console.warn('[BackgroundFetch] default onTimeout callback fired.  You should provide your own onTimeout callbcak to .configure(options, onEvent, onTimeout)');\n        BackgroundFetch.finish(taskId);\n      };\n    }\n    const myOnTimeout = onTimeout;\n    if (subscriber !== null) {\n      subscriber.remove();\n      subscriber = null;\n    }\n    subscriber = NativeModule.addListener(EVENT_FETCH, event => {\n      if (!event.timeout) {\n        onEvent(event.taskId);\n      } else {\n        myOnTimeout(event.taskId);\n      }\n    });\n    config = config || {};\n    return new Promise((resolve, reject) => {\n      NativeModule.configure({\n        options: config\n      }).then(result => {\n        resolve(result.status);\n      }).catch(error => {\n        console.warn(TAG, \"ERROR:\", error);\n        reject(error.message);\n      });\n    });\n  }\n  /**\n  * Execute a custom task in addition to the one initially provided to [[configure]].\n  * This event can be configured to either a \"ONE-SHOT\" or \"PERIODIC\" with [[TaskConfig.periodic]].\n  *\n  * ```javascript\n  * // You must ALWAYS first configure BackgroundFetch.\n  * const status = await BackgroundFetch.configure({\n  *   minimumFetchInterval: 15\n  * }, async (taskId) => {\n  *   console.log('[BackgroundFetch] EVENT', taskId);\n  *   if (taskId === 'my-custom-task') {\n  *     console.log('Handle your custom-task here');\n  *   } else {\n  *     console.log('This is the default, periodic fetch task');\n  *   }\n  *   // Always signal completion of your tasks.\n  *   BackgroundFetch.finish(taskId);\n  * }, async (taskId) => {\n  *   console.log('[BackgroundFetch] TIMEOUT', taskId);\n  *   if (taskId === 'my-custom-task') {\n  *     console.log('My custom task timed-out');\n  *   } else {\n  *     console.log('The default, periodic fetch task timed-out');\n  *   }\n  *   BackgroundFetch.finish(taskId);\n  * });\n  *\n  * // Execute an additional custom-task.\n  * BackgroundFetch.scheduleTask({\n  *   taskId: 'my-custom-task',  // <-- REQUIRED\n  *   delay: 10000,              // <-- REQUIRED\n  *   periodic: false            // <-- ONE-SHOT (default)\n  * })\n  * ```\n  */\n  static scheduleTask(config) {\n    return new Promise((resolve, reject) => {\n      if (typeof config.delay !== 'number') {\n        const delay = parseInt(config.delay, 10);\n        if (delay === NaN) {\n          reject('[BackgroundFetch] TaskConfig.delay must be a number: ' + config.delay);\n          return;\n        }\n        config.delay = delay;\n      }\n      return NativeModule.scheduleTask({\n        options: config\n      }).then(() => {\n        resolve();\n      }).catch(error => {\n        reject(error.message);\n      });\n    });\n  }\n  /**\n  * Start subscribing to fetch events.\n  *\n  * __Note:__ The inital call to [[configure]] *automatically* calls __`BackgroundFetch.start()`__\n  *\n  * ```javascript\n  *   async initBackgroundFetch() {\n  *     // Calling .configure() automatically starts the plugin.\n  *     const status = await BackgroundFetch.configure({\n  *       minimumFetchInterval: 15\n  *     }, async (taskId) => {  // <---------------- Event handler.\n  *       console.log('[BackgroundFetch] EVENT:', taskId);\n  *       BackgroundFetch.finish(taskId);\n  *     }, async (taskId) => {  // <---------------- Event timeout handler\n  *       console.log('[BackgroundFetch] TIMEOUT:', taskId);\n  *       // [REQUIRED] Signal to the OS that your work is complete.\n  *       BackgroundFetch.finish(taskId);\n  *     });\n  *   }\n  *\n  *   // Stop BackgroundFetch\n  *   onClickStop() {\n  *     BackgroundFetch.stop();\n  *   }\n  *\n  *   // Re-start BackgroundFetch\n  *   onClickStart() {\n  *     BackgroundFetch.start();\n  *   }\n  *\n  * ```\n  */\n  static start() {\n    return new Promise((resolve, reject) => {\n      NativeModule.start().then(result => {\n        resolve(result.status);\n      }).catch(error => {\n        reject(error.message);\n      });\n    });\n  }\n  /**\n  * Stop subscribing to fetch events.\n  *\n  * ```javascript\n  * // Stop everything.\n  * BackgroundFetch.stop();\n  * ```\n  *\n  * You may also provide an optional __`taskId`__ to stop a [[scheduleTask]]:\n  *\n  * ```javascript\n  * // Stop a particular task scheduled with BackgroundFetch.scheduleTask\n  * await BackgroundFetch.scheduleTask({\n  *   taskId: 'my-custom-task',\n  *   delay: 10000,\n  *   periodic: false\n  * });\n  * .\n  * .\n  * .\n  * BackgroundFetch.stop('my-custom-task');\n  * ```\n  */\n  static stop(taskId) {\n    return new Promise((resolve, reject) => {\n      NativeModule.stop({\n        taskId: taskId\n      }).then(() => {\n        resolve();\n      }).catch(error => {\n        reject(error.message);\n      });\n    });\n  }\n  /**\n  * You must execute `BackgroundFetch.finish(taskId)` within your fetch-callback to signal completion of your task.\n  *\n  * If you *fail* to call `.finish()`, the OS __will punish your app for poor behaviour and stop firing events__.\n  *\n  * ```javascript\n  * await BackgroundFetch.configure({\n  *   minimumFetchInterval: 15\n  * }, async (taskId) => {\n  *   console.log('[BackgroundFetch] EVENT', taskId);\n  *   // Always signal completion of your tasks.\n  *   BackgroundFetch.finish(taskId);\n  * }, async (taskId) => {\n  *   console.log('[BackgroundFetch] TIMEOUT', taskId);\n  *   // Always signal completion of your tasks.\n  *   BackgroundFetch.finish(taskId);\n  * });\n  * ```\n  */\n  static finish(taskId) {\n    return NativeModule.finish({\n      taskId: taskId\n    });\n  }\n  /**\n  * Query the BackgroundFetch API status\n  *\n  * ```javascript\n  * // Checking BackgroundFetch status:\n  * const status = await BackgroundFetch.status();\n  *\n  * if (status !== BackgroundFetch.STATUS_AVAILABLE) {\n  *   // Uh-oh:  we have a problem:\n  *   if (status === BackgroundFetch.STATUS_DENIED) {\n  *     alert('The user explicitly disabled background behavior for this app or for the whole system.');\n  *   } else if (status === BackgroundFetch.STATUS_RESTRICTED) {\n  *     alert('Background updates are unavailable and the user cannot enable them again.')\n  *   }\n  * }\n  * ```\n  *\n  * | BackgroundFetchStatus              | Description                                     |\n  * |------------------------------------|-------------------------------------------------|\n  * | `BackgroundFetch.STATUS_RESTRICTED`  | Background fetch updates are unavailable and the user cannot enable them again. For example, this status can occur when parental controls are in effect for the current user. |\n  * | `BackgroundFetch.STATUS_DENIED`      | The user explicitly disabled background behavior for this app or for the whole system. |\n  * | `BackgroundFetch.STATUS_AVAILABLE`   | Background fetch is available and enabled.      |\n  */\n  static status() {\n    return new Promise((resolve, reject) => {\n      NativeModule.status().then(result => {\n        resolve(result.status);\n      }).catch(error => {\n        reject(error.message);\n      });\n    });\n  }\n}\nexport * from './definitions';","map":{"version":3,"names":["registerPlugin","EVENT_FETCH","TAG","STATUS_RESTRICTED","STATUS_DENIED","STATUS_AVAILABLE","NETWORK_TYPE_NONE","NETWORK_TYPE_ANY","NETWORK_TYPE_UNMETERED","NETWORK_TYPE_NOT_ROAMING","NETWORK_TYPE_CELLULAR","NativeModule","subscriber","BackgroundFetch","configure","config","onEvent","onTimeout","console","warn","taskId","finish","myOnTimeout","remove","addListener","event","timeout","Promise","resolve","reject","options","then","result","status","catch","error","message","scheduleTask","delay","parseInt","NaN","start","stop"],"sources":["../../src/index.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}